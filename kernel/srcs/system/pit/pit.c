/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pit.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vvaucoul <vvaucoul@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/06/22 20:07:16 by vvaucoul          #+#    #+#             */
/*   Updated: 2024/07/30 00:57:46 by vvaucoul         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <system/pit.h>

#include <asm/asm.h>
#include <macros.h>
#include <multitasking/scheduler.h>
#include <system/io.h>
#include <system/irq.h>

static volatile uint64_t pit_ticks = 0;			  // Number of seconds
static volatile uint64_t pit_subticks = 0;		  // Number of ticks
static volatile uint64_t pit_continous_ticks = 0; // Number of ticks since the kernel start

/**
 * @brief Initializes the Programmable Interval Timer (PIT).
 *
 * This function is responsible for initializing the Programmable Interval Timer (PIT).
 * It sets up the necessary configurations and registers to enable the PIT functionality.
 *
 * @note This function should be called before using the PIT.
 */
static void pit_init(void) {
	// Send the command byte
	outb(PIT_COMMAND, 0x36); // Command byte: 0x36 for mode 3 (square wave generator)

	// Send the divisor value (low byte first, then high byte)
	uint8_t low = (uint8_t)(PIT_DIVISOR & PIT_MASK);
	uint8_t high = (uint8_t)((PIT_DIVISOR >> 8) & PIT_MASK);

	outb(PIT_CHANNEL_0, low);
	outb(PIT_CHANNEL_0, high);
}

/**
 * @brief Handles the interrupt generated by the Programmable Interval Timer (PIT).
 *
 * @param r The structure containing the register values at the time of the interrupt.
 */
static void pit_interrupt_handler(__unused__ struct regs *r) {
	pit_subticks++;
	pit_continous_ticks++;

	if (pit_subticks >= TIMER_PHASE) {
		pit_ticks++;
		pit_subticks = 0;
	}

	if (pit_continous_ticks >= PIT_MAX_TICKS) {
		pit_continous_ticks = 0;
	}

	if (pit_subticks % TASK_FREQUENCY == 0 && scheduler_initialized) {
		switch_task();
	}
	pic8259_send_eoi(IRQ_PIT);
}

/**
 * @brief Sets up the Programmable Interval Timer (PIT).
 *
 * This function initializes the Programmable Interval Timer (PIT) and sets up its configuration.
 *
 * @note This function assumes that the PIT is accessible at the specified file path.
 */
void pit_setup() {
	pit_init();
	irq_install_handler(IRQ_PIT, pit_interrupt_handler);
}

/**
 * @brief Busy wait for a given number of ticks
 * @param ticks Number of ticks to wait
 *
 * This function is used to wait for a given number of ticks.
 */
void busy_wait(uint64_t ticks) {
	uint64_t start_tick = pit_get_continous_ticks();

	while (1) {
		uint64_t current_tick = pit_get_continous_ticks();
		uint64_t elapsed;

		if (current_tick >= start_tick) {
			elapsed = current_tick - start_tick;
		} else {
			// Handle wraparound
			elapsed = (PIT_MAX_TICKS - start_tick) + current_tick + 1;
		}

		if (elapsed >= ticks) {
			break;
		}

		__asm__ volatile("sti\n\thlt\n\tcld");
	}
}

/**
 * @brief Waits for a specified number of timer ticks.
 *
 * @param ticks The number of ticks to wait.
 */
void pit_wait(uint64_t ticks) {
	task_t *task = get_current_task();

	if (!scheduler_initialized || !task || (task && task->pid == 0)) {
		// If no multitasking, just busy-wait
		busy_wait(ticks);
		return;
	}

	// If the task is running, put it to sleep
	if (task->state == TASK_RUNNING) {
		uint64_t start_tick = pit_get_continous_ticks();
		uint64_t wake_up_tick = start_tick + ticks;

		task->state = TASK_SLEEPING;
		task->wake_up_tick = wake_up_tick;

		// Yield the CPU to allow other tasks to run.
		while (task->state == TASK_SLEEPING) {
			uint64_t current_tick = pit_get_continous_ticks();

			// Check for wraparound
			if ((current_tick >= start_tick && current_tick >= wake_up_tick) ||
				(current_tick < start_tick && current_tick >= (wake_up_tick % PIT_MAX_TICKS))) {
				task->state = TASK_RUNNING;
			}

			__asm__ volatile("sti\n\thlt\n\tcld");
		}
	} else {
		// If the task is not running, just busy-wait
		busy_wait(ticks);
	}
}

/**
 * @brief Pauses the execution of the kernel.
 *
 * This function is used to pause the execution of the kernel for a certain period of time.
 * It is typically used for introducing delays or waiting for specific events.
 */
void kpause(void) {
	ASM_CLI();
	while (1) {
		__asm__ volatile("nop");
	}
}

/**
 * @brief Retrieves the current tick count of the Programmable Interval Timer (PIT).
 *
 * @return The current tick count of the PIT.
 */
uint64_t pit_get_ticks(void) {
	return pit_ticks;
}

/**
 * @brief Retrieves the number of subticks from the Programmable Interval Timer (PIT).
 *
 * This function returns the current count of subticks from the PIT. Subticks are smaller units of time
 * that are used for precise timing measurements.
 *
 * @return The number of subticks from the PIT.
 */
uint64_t pit_get_subticks(void) {
	return pit_subticks;
}

/**
 * @brief Retrieves the current value of the continuous ticks from the PIT (Programmable Interval Timer).
 *
 * @return The current value of the continuous ticks.
 */
uint64_t pit_get_continous_ticks(void) {
	return pit_continous_ticks;
}

/**
 * @brief Reads the current value of the Programmable Interval Timer (PIT) count.
 *
 * @return The current value of the PIT count.
 */
uint32_t read_pit_count(void) {
	uint32_t count = 0;

	outb(PIT_COMMAND, 0b0000000);
	count = inb(PIT_CHANNEL_0);		  // Low byte
	count |= inb(PIT_CHANNEL_0) << 8; // High byte

	return (count);
}

/**
 * @brief Displays the phase of the PIT (Programmable Interval Timer).
 *
 * This function is responsible for displaying the current phase of the PIT.
 * The PIT is a hardware timer that generates periodic interrupts at a specified frequency.
 * This function can be used to monitor the progress of the PIT and ensure that it is functioning correctly.
 */
void pit_display_phase(void) {
	printk("%8%% Phase: %d\n", pit_subticks);
	printk("%8%% Seconds: %d\n", pit_ticks);
	printk("%8%% HZ: %d\n", (size_t)TIMER_PHASE);
}